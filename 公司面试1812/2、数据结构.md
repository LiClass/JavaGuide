### 2、树的遍历（前序遍历和后序遍历）

前序遍历：中、左、右
中序遍历：左、中、右
后序遍历: 左、右、中

### 1、队列和栈的相互实现；
队列和栈相互实现

双队列实现栈：

就是要实现先进后出。。。。
入队就正常入队，，出栈时，，吧除了最后一个全部出队，，然后剩下那个就出队了，，再次出队就再返回。入队就是入那个非空的队列

双栈实现 队列

正常入栈、出队时，除了最后一个全部出栈，，然后就出队了，，，如果第二个栈不为空，则直接出栈，，为空则像之前一样，，，入栈则入第一个





### 是否了解springcloud dubbo
### 用过那些数据库

### 加密解密算法

RSA、AES、DES、MD5、SHA

### Promise 异步编程框架

### Spring springboot的区别





### 索引数据结构  实现方式

B-Tree 和B+Tree

### Nginx
方向代理服务器

### Netty
### 存储引擎
mysql不同的存储方式

### 分库分表

### 前端接口优化
### Cdn原理
可以根据互联网环境重新导向，寻找最快路径，
选择地理位置，当前服务状态等
### Http协议，http2  状态码 001

1**临时响应，服务器已经收到但是需要请求者继续操作
2**成功
3**重定向
4**客户端异常
5**服务端异常


### Api gateway
### Spring cloud组件
### 微服务
### Git流程  分支图
### 拆包和粘包

- 应用程序write写入的字节大小大于套接口发送缓冲区大小；
- 进行MSS大小的TCP分段；
- 以太网帧的payload大于MTU进行IP分片。
- 


#### 由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。

- 消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；

- 在包尾增加回车换行符进行分割，例如FTP协议；

- 将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32来表示消息的总长度；

- 更复杂的应用层协议。
- Netty可解决


### 看过源码
### 看过哪些书

### Sql执行解析流程

当客户端把SQL语句传送到服务器后,服务器进程会对该语句进行解析。同理,这个解析的工作,也是在服务器端所进行的。虽然这只是一个解析的动作,但是它会做很多小动作：

　　1. 查询高速缓存(library cache) 。

　　服务器进程在接到客户端传送过来的SQL语句时,不会直接去数据库查询，而是会先在数据库的高速缓存中去查找是否存在相同语句的执行计划。如果在数据高速缓中, 则服务器进程就会直接执行这个SQL 语句,省去后续的工作。所以,采用高速数据缓存的话, 可以提高SQL 语句的查询效率。一方面是从内存中读取数据要比从硬盘中的数据文件中读取数据效率要高,另一方面,也是因为这个语句解析的原因。 不过这里要注意一点,这个数据缓存跟有些客户端软件的数据缓存是两码事。有些客户端软件为了提高查询效率,会在应用软件的客户端设置数据缓存。由于这些数据缓存的存在,可以提高客户端应用软件的查询效率。但是,若其他人在服务器进行了相关的修改,由于应用软件数据缓存的存在,导致修改的数据不能及时反映到客户端上。从这也可以看出,应用软件的数据缓存跟数据库服务器的高速数据缓存不是一码事。

　　2. 语句合法性检查(data dict cache) 。

　　当在高速缓存中找不到对应的SQL 语句时,则服务器进程就会开始检查这条语句的合法性。这里主要是对SQL 语句的语法进行检查,看看其是否合乎语法规则。如果服务器进程认为这条SQL 语句不符合语法规则的时候,就会把这个错误信息,反馈给客户端。在这个语法检查的过程中, 不会对SQL语句中所包含的表名、列名等等进行检查，它只是语法上的检查。

　　3. 语言含义检查(data dict cache) 。

　　若SQL 语句符合语法上的定义的话,则服务器进程接下去会对语句中的字段、表等内容进行检查。看看这些字段、表是否在数据库中。如果表名与列名不准确的话,则数据库会就会反馈错误信息给客户端。所以, 有时候我们写select语句的时候,若语法与表名或者列名同时写错的话,则系统是先提示说语法错误,等到语法完全正确后,再提示说列名或表名错误。

　　4. 获得对象解析锁(control structer)。
　　当语法、语义都正确后,系统就会对我们需要查询的对象加锁。这主要是为了保障数据的一致性,防止我们在查询的过程中,其他用户对这个对象的结构发生改变。

5. 数据访问权限的核对(data dict cache)。

　　当语法、语义通过检查之后,客户端还不一定能够取得数据。服务器进程还会检查,你所连接的用户是否有这个数据访问的权限。若你连接上服务器 的用户不具有数据访问权限的话,则客户端就不能够取得这些数据。有时候我们查询数据的时候,辛辛苦苦地把SQL 语句写好、编译通过,但是最后系统返回个没有权限访问数据的错误信息,所以,要注意这个问题,数据库服务器进程先检查语法与语义,然后才会检查访问权限。

　　6.  确定最佳执行计划。

　　当语句与语法都没有问题,权限也匹配的话,服务器进程还是不会直接对数据库文件进行查询。服务器进程会根据一定的规则,对这条语句进行优化。不过要注意,这个优化是有限的。一般在应用软件开发的过程中, 需要对数据库的sql 语言进行优化,这个优化的作用要大大地大于服务器进程的自我优化。所以,一般在应用软件开发的时候,数据库的优化是少不了的。当服务器进程的优化器确定这条查询语句的最佳执行计划后, 就会将这条SQL 语句与执行计划保存到数据高速缓存(library cache)。如此的话,等以后还有这个查询时,就会省略以上的语法、语义与权限检查的步骤, 而直接执行SQL 语句, 提高SQL 语句处理效率。

第三步:语句执行  

　　语句解析只是对SQL 语句的语法进行解析,以确保服务器能够知道这条语句到底表达什么意思。语句解析完成之后, 数据库服务器进程才会真正的执行这条SQL 语句。这个语句执行也分两种情况。 一是若被选择行所在的数据块已经被读取到数据缓冲区的话,则服务器进程会直接把这个数据传递给客户端,而不是从数据库文件中去查询数据。 二是若数据不在缓冲区中,则服务器进程将从数据库文件中查询相关数据,并把这些数据放入到数据缓冲区中(buffer cache)。

第四步:提取数据

　　当语句执行完成之后,查询到的数据还是在服务器进程中,还没有被传送到客户端的用户进程。所以,在服务器端的进程中,有一个专门负责数据提取的一段代码。它的作用就是把查询到的数据结果返回给用户端进程,从而完成整个查询动作。

　　从这整个查询处理过程中,我们在数据库开发或者应用软件开发过程中,需要注意以下几点:

　　一是要了解数据库缓存跟应用软件缓存是两码事情。

### 正则表达式的实现

### Redis的数据结构 用途
### Es 全文搜索  倒排索引

### SparkSql架构原理
### 对象存储 ceph





### 数据库事务
### Spring aop
### Spring 事务使用

### 分布式事务








### Aba问题
每一次倒水假设有一个自动记录仪记录下，这样主人回来就可以分辨在她离开后是否发生过重新倒满的情况。这也是解决ABA问题目前采用的策略。
### Cas


### 关于数字货币   是否可以用比特币作为法币，人们是否接受其作为法币



### 多叉树
### 链表数组循环构建新链表


### Storm学习
低延迟、高可用、可扩展、分布式
主节点：nimbus：分配任务给supervisor，资源调度，开启woker
从节点：supervisor：执行woker，启动或停止自己管理的woker

woker:执行任务的逻辑进程
task：在woker中每一个spout/bolt就是一个task
spout：开始任务节点
bolt：任务处理节点



### bit map算法
利用字节位置存储数据





