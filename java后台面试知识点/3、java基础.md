### 哪些关键字可以修饰interface
**public** 
### 面向对象的七个原则
- 单一职责原则，每一个类应该专注于做一件事情。

- 里氏替换原则，超类存在的地方，子类是可以替换的。

- 依赖倒置原则，实现尽量依赖抽象，不依赖具体实现。

- 接口隔离原则，应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。

- 迪米特法则，又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。

- 开闭原则，面向扩展开放，面向修改关闭。

- 组合/聚合复用原则，尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。

### 常用排序
- 选择排序是遍历数组，然后选出最大最小值然后与已经排好的后一位交换
- 快速排序是找基准数，然后找到比他小的放一侧，大的另一侧，然后在分别排序


### 稳定的排序
- 冒泡排序
- 直接插入排序
- 归并排序
- 基数排序

### 不稳定排序
- shell排序
- 直接排序
- 堆排序
- 快速排序

### BufferWriter write  append的区别
- write是在CharSequence类型出来之前的函数，write形参不能为null，返回值为void

- append接收的形参为CharSequence，可以为空，返回值为Writer，所以可以使用链式结构。

### equals和==针对包装类型
对于包装类型，除了浮点数float、double其他的都将在 相应的缓存保存-128-127，如果超过这个数或为浮点数则新建对象
### Integer的缓存
Interger、character、Byte、Long、Short等都有缓存机制，一般是-128-127，而Charater的范围为0-127，当利用自动装箱或valueOf函数时，会检测是否存在已有对象，然后赋予同一引用



### 运算符的优先级

等级 | 符号
---|---
括号(1级) | () []数组取下标  .(取成员变量)
单目(2级)(从右向左)|! +(正)-(负) ~（按位取反）++ --
算术(3-5级)|* / % 》+ - 》 << >> >>>
关系(6-7级)|	< <= > >= instanceof---->>>> == !=
位(8-10级)(特殊的单目)|	& 》^ 》|
逻辑(11-12级)|	&& ---->>>> ||
条件(13级)|	? :
赋值(14级)(从右向左)|	= += -+ *= /= %= &= |= ^= ~= <<= >>= >>>=


### 使用Stream进行去重和导出为一个list

### String 和 StringBuffer和StringBuilder

初始化大小为16，无参数的时候，当构造函数有参数，大小为str.length()+16;
扩容机制：在空间不足时候，进行扩容，扩容方式为计算扩容大小为原来大小的2倍+2，如果新计算的大小仍然不足，则新字符串大小为原来大小+新增字符串大小。

String|	StringBuffer|StringBuilder
---|---|---
String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间	|StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量|可变类，速度更快
不可变|可变|可变
空 |线程安全|线程不安全
空|多线程操作字符串|单线程操作字符串

### 类加载机制，顺序

加载->链接（验证+准备+解析）->初始化（使用前的准备）->使用->卸载 

1. 加载 
    
首先通过一个类的全限定名来获取此类的二进制字节流；其次将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；最后在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。总的来说就是查找并加载类的二进制数据。 
2. 链接： 
    - 验证：确保被加载类的正确性； 
    - 准备：为类的静态变量分配内存，并将其初始化为默认值； 
    - 解析：把类中的符号引用转换为直接引用； 
> 注：在java类编译为class文件是其并不清楚它内部引用的类的实际位置，此时使用符号引用代替，之后在链接解析结阶段替换为直接 引用。

3. 为类的静态变量赋予正确的初始值 

4. 类的初始化 

    **类什么时候才被初始化**
    - 创建类的实例，也就是new一个对象 
    - 访问某个类或接口的静态变量，或者对该静态变量赋值 
    - 调用类的静态方法 
    - 反射（Class.forName(“com.lyj.load”)） 
    - 初始化一个类的子类（会首先初始化子类的父类） 
    - JVM启动时标明的启动类，即文件名和类名相同的那个类 
（2）类的初始化顺序 
　　1）如果这个类还没有被加载和链接，那先进行加载和链接 
　　2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） 
　　3）假如类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 
　　4）总的来说，初始化顺序依次是：（静态变量、静态初始化块）–>（变量、初始化块）–> 构造器；如果有父类，则顺序是：父类static方法 –> 子类static方法 –> 父类构造方法- -> 子类构造方法 


https://blog.csdn.net/eff666/article/details/52203406

每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，
等下次加载的时候就可以直接返回了。



### 单例模式 为什么用单例模式
保证访问对象的唯一性
频繁实例化然后就销毁的对象、
创建实例太耗时，消耗太多资源，但是又经常用到



### 代理模式


### C语言实现oop
https://my.oschina.net/hevakelcj/blog/551474


### 常用的算法 数据结构
数组、链表、栈、队列、树、图、

### Nio使用

### 数据库四种隔离等级

- 未授权读取，也称为读未提交：Read Uncommitted 允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。
- 授权读取也称为读提交（Read-Committed）：允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行
- 可重复读取（Repeatable Read）：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。
- 可串行化Serializable：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。
默认系统事务隔离级别是READ COMMITTED,也就是读已提交

Mysql默认是可重复读的级别

### 事务具有四个特征：
- 原子性（ Atomicity ）事务所包含的数据库操作要么都做，要么都不做
- 一致性（ Consistency ）事务前后，所有的数据都保持一致的状态，例如：事务之前A，B两个账户的总和是10万(A: 4W, B: 6W), 现在A转账2W给B (A: 2W, B: 8W)

A, B账户总和依旧是10W，如果不是10W的话，则事务前后对于账户总和这种资源是不一致的。
- 隔离性（ Isolation ）事务对数据的操作不能够受到其他事务的影响
- 持续性（ Durability ）数据库事务一旦提交，其对数据库中数据的改变应该是永久性的

### Java基础之==与equal()的区别
==是比较的栈中的元素是否相等、equal比较的是在堆中的大小

